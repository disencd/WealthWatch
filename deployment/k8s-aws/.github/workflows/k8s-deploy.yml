name: Deploy to Kubernetes (EKS)

on:
  push:
    branches: [main]
    paths:
      - 'deployment/k8s-aws/**'
      - 'Dockerfile'
      - 'go.mod'
      - 'go.sum'
      - '**/*.go'
  pull_request:
    branches: [main]
    paths:
      - 'deployment/k8s-aws/**'

env:
  AWS_REGION: us-east-1
  CLUSTER_NAME: splitwise-cluster
  NAMESPACE: splitwise
  ECR_REPOSITORY: splitwise

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Run tests
        run: go test -v ./...

      - name: Run security scan
        uses: securecodewarrior/github-action-add-sarif@v1
        if: always()
        with:
          sarif-file: 'security-scan-results.sarif'

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          
          # Push images
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Output image name for next steps
          echo "IMAGE=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

  deploy-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy to staging namespace
        run: |
          # Create staging namespace if it doesn't exist
          kubectl create namespace splitwise-staging --dry-run=client -o yaml | kubectl apply -f -
          
          # Apply manifests with staging overrides
          helm template splitwise ./deployment/k8s-aws/k8s \
            --namespace splitwise-staging \
            --set image.repository=${{ env.IMAGE }} \
            --set image.tag=${{ github.sha }} \
            --set environment=staging \
            --set ingress.host=staging.splitwise.yourdomain.com | kubectl apply -f -
          
          # Wait for deployment
          kubectl rollout status deployment/splitwise -n splitwise-staging --timeout=600s

      - name: Run integration tests
        run: |
          # Wait for ingress to be ready
          kubectl wait --for=condition=ready --timeout=300s ingress/splitwise-ingress -n splitwise-staging
          
          # Get ingress URL
          INGRESS_URL=$(kubectl get ingress splitwise-ingress -n splitwise-staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Run health check
          curl -f http://$INGRESS_URL/health || exit 1
          
          # Run basic API tests
          curl -f http://$INGRESS_URL/api/v1/health || exit 1

  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Deploy to production
        run: |
          # Backup current deployment
          kubectl get deployment splitwise -n ${{ env.NAMESPACE }} -o yaml > deployment-backup.yaml
          
          # Update deployment with new image
          kubectl set image deployment/splitwise splitwise=${{ env.IMAGE }} -n ${{ env.NAMESPACE }}
          
          # Wait for rollout to complete
          kubectl rollout status deployment/splitwise -n ${{ env.NAMESPACE }} --timeout=600s
          
          # Verify deployment
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=splitwise

      - name: Run smoke tests
        run: |
          # Wait for ingress to be ready
          sleep 30
          
          # Get ingress URL
          INGRESS_URL=$(kubectl get ingress splitwise-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Run health checks
          curl -f https://$INGRESS_URL/health || exit 1
          curl -f https://$INGRESS_URL/api/v1/health || exit 1
          
          # Test authentication endpoint
          curl -f -X POST https://$INGRESS_URL/api/v1/auth/login \
            -H "Content-Type: application/json" \
            -d '{"email":"test@example.com","password":"test"}' || true

      - name: Update deployment status
        if: success()
        run: |
          echo "✅ Deployment to production successful!"
          # Send Slack notification (optional)
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"✅ Splitwise deployed successfully to production\nVersion: ${{ github.sha }}\nURL: https://splitwise.yourdomain.com"}' \
          #   ${{ secrets.SLACK_WEBHOOK }}

      - name: Rollback on failure
        if: failure()
        run: |
          echo "❌ Deployment failed! Rolling back..."
          kubectl rollout undo deployment/splitwise -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/splitwise -n ${{ env.NAMESPACE }} --timeout=300s
          
          # Send Slack notification (optional)
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"❌ Splitwise deployment failed and was rolled back\nVersion: ${{ github.sha }}"}' \
          #   ${{ secrets.SLACK_WEBHOOK }}

  security-scan:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  monitoring:
    needs: deploy-production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

      - name: Check pod health
        run: |
          # Check if all pods are running
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=splitwise
          
          # Check HPA status
          kubectl get hpa -n ${{ env.NAMESPACE }}
          
          # Check resource usage
          kubectl top pods -n ${{ env.NAMESPACE }} || true

      - name: Verify external connectivity
        run: |
          # Get ingress URL
          INGRESS_URL=$(kubectl get ingress splitwise-ingress -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Continuous health check
          for i in {1..10}; do
            if curl -f https://$INGRESS_URL/health; then
              echo "Health check $i: PASSED"
            else
              echo "Health check $i: FAILED"
              exit 1
            fi
            sleep 10
          done
